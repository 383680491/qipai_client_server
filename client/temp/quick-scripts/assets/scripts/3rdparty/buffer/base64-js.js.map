{"version":3,"sources":["base64-js.js"],"names":["exports","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","Uint8Array","Array","code","i","len","length","charCodeAt","placeHoldersCount","b64","Error","l","tmp","placeHolders","arr","L","tripletToBase64","num","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len2"],"mappings":"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","file":"base64-js.js","sourceRoot":"..\\..\\..\\..\\..\\..\\assets\\scripts\\3rdparty\\buffer","sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n"]}